#ifndef __basic_timer_hpp__
#define __basic_timer_hpp__

#if defined (USE_HAL_DRIVER)
    #undef USE_HAL_DRIVER
#endif
#include <stm32l4xx.h>

namespace stm32::timer
{

/// @brief The timer peripheral block
enum class Block
{
    T6,
    T7
};


class BasicTimer
{
public:

    /// @brief Status Register bit absractions for BasicTimer
    enum class StatusBits
    {
        UIF = TIM_SR_UIF
    };

    /// @brief DMA/Interrupt Enable Register bit absractions for BasicTimer
    enum class DierBits
    {
        UDE = TIM_DIER_UDE,
        UIE = TIM_DIER_UIE
    };

    /// @brief Construct a new Basic Timer object
    /// @param timer_id The timer peripheral to enable
    /// @param delayed_start if true enable timer now, if false leave disabled. True by default
    /// @note Implicit defaults are: opm = false, urs_cnt_only = false, arpe = true,
    BasicTimer(Block timer_block, uint16_t psc, uint16_t arr, uint16_t cnt = 0, bool delayed_start = false);

    void enable(bool enable_timer);

    /// @brief Set the "one pulse mode"
    /// @param opm If true set "one pulse mode", false by default.
    void set_opm(bool opm = false);

    /// @brief Set the "Update Request Source"
    /// @param urs_cnt_only If true limit update interrupt/DMA request to counter overflow/underflow only, 
    /// false by default.
    void set_urs(bool urs_cnt_only = false);

    /// @brief Set the "Auto-reload Preload"
    /// @param arpe If false TIMx_ARR register is not buffered, true by default.
    void set_arpe(bool enable_arpe = true);

    /// @brief Set the "Update Disable"
    /// @param enable_uev if true update event (uev) is generated by counter overflow/undeflow, 
    /// setting UG bit or update via slave controller. True by default.
    void set_udis(bool enable_uev = true);

    void set_psc(uint16_t psc);
    void set_arr(uint16_t arr);
    void set_cnt(uint16_t cnt);

    /// @brief Set the interrupts object
    /// @param dier TIM_DIER_UDE, TIM_DIER_UIE
    /// @param prio IRQ priority (numerically lower is higher priority)
    void set_interrupts(DierBits dier, uint32_t prio);

    /// @brief Check the "Status Register" bit. 
    /// @param sr TIM_SR_UIF
    /// @param auto_clear if true the bit is cleared on read. True by default.
    /// @return true if bit is set, false it not
    bool is_status_set(StatusBits sr, bool auto_clear = true);

private:
    TIM_TypeDef* m_timer_registers;
    Block m_timer_block;
};

extern "C" void TIM6_DACUNDER_IRQHandler(void);
extern "C" void TIM7_IRQHandler(void);


} // namespace stm32::timer


#endif // __basic_timer_hpp__